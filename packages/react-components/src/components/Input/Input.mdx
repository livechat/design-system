import { Canvas, ArgTypes, Meta, Title } from '@storybook/blocks';

import * as InputStories from './Input.stories';

<Meta of={InputStories} />

<Title>Input</Title>

[Component API](#ComponentAPI) | [Content Spec](#ContentSpec)

<Canvas of={InputStories.Default} sourceState="none" />

#### Example implementation

```jsx
<Input inputSize="large" placeholder="Placeholder text" onChange={(e) => {}} />
```

## Component API <a id="ComponentAPI" />

<b>Inherits Standard React Input Props</b>: This component inherits all the
properties of the standard React input element. This means that in addition to
the custom properties we provide, you can use any of the React input props as
documented in the React official documentation.

<b>Custom Properties</b>: Below are the custom properties that our component
introduces. These are designed to complement and enhance the standard input
behavior:

<ArgTypes of={InputStories.Default} sort="requiredFirst" />

## Autocomplete capabilities <a id="AutoComplete" />

The `AutoComplete` component is a wrapper around the `Input` component that provides a list of suggestions based on the user's Input. It requires a list of unique `options` to be passed. All of `Input`'s props are available and the component can be used both controlled and uncontrolled.

### Implementation tips

#### Custom list items

The `IAutoCompleteListItem` is a subset of `IPickerListItem` that restricts the incoming props to the ones relevant for the `AutoComplete` component. This allows you to customise the list items in a simpler way than the `IPickerListItem`.

The two crucial props are `name` and `customElement`. The `name` prop is the value that will be set when the user selects the option and the string that will be checked for while searching. The `customElement` prop is the element that will be displayed in the list. Other props are also available, see the **Picker docs** for more details

When providing custom elements, ensure that they reflect the `name` property accurately. The value in the input won't be the custom element, but the `name` prop.
```jsx
// Don't: 
const options = [{
  name: 'Option 1',
  customElement: <strong>One</strong> // different from the name prop, so it will disappear when the user types in "One"
}]

// Do:
const options = [{
  name: 'Option 1',
  customElement: <strong>Option 1</strong>, // typing "Option 1" will show the custom element
}]
```

#### Always show all options

While the component handles filtering the provided options for you, you may want to do that yourself. In that case, use the `alwaysShowAllOptions` prop to show all options regardless of the input value - then you can use `onChange` to listen to the input value and filter the options yourself. 

```jsx
const [filteredOptions, setFilteredOptions] = useState(options);

const handleChange = debounce((e) => {
  const filteredOptions = Api.getOptions(e.target.value);
}, 300);

<AutoComplete
  options={filteredOptions}
  alwaysShowAllOptions
  placeholder="Type something..."
  onChange={handleChange}/>
```

<ArgTypes of={InputStories.AutoCompleteStory}/>

## Content Spec <a id="ContentSpec" />

<a
  className="sb-unstyled"
  href="https://www.figma.com/file/9FDwjR8lYvincseDkKypC4/Component-Documentations?type=design&node-id=762-65501&mode=dev"
  target="_blank"
>
  Go to Figma documentation
</a>
